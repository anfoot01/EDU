<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LearnCode — Learn Programming Languages</title>
    <link rel="stylesheet" href="course-page.css">
    <link rel="stylesheet" href="./header.css">
    <link rel="apple-touch-icon" sizes="180x180" href="./img/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="./img/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="./img/favicon-16x16.png">
    <link rel="manifest" href="./img/site.webmanifest">
</head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-VBCKQFRCH2"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());

    gtag('config', 'G-VBCKQFRCH2');
</script>

<body>
    <div class="container">


        <header>
            <div class="logo" aria-hidden="true">
                <a href="./index.html">
                    <img class="logo-img" src="./img/android-chrome-512x512.png" alt="logo">
                </a>
            </div>
            <nav class="nav">
                <div class="burger" id="burger">&#9776;</div>
                <ul class="nav-list">
                    <li><span class="close-menu" id="close-menu">&times;</span></li>
                    <li class="nav-link" data-section="Python"><a href="./python.html">Python</a></li>
                    <li class="nav-link" data-section="Javascript"><a href="./javascript.html">Javascript</a></li>
                    <li class="nav-link" data-section="SQL"><a href="./sql.html">SQL</a></li>
                    <li class="nav-link" data-section="Go"><a href="./go.html">Go</a></li>
                    <li class="nav-link" data-section="Rust"><a href="./rust.html">Rust</a></li>
                    <li class="nav-link" data-section="C++"><a href="./cpp.html">C++</a></li>
                </ul>
            </nav>
        </header>
        <h1>
            Course <i>"Rust - Mini Course"</i></h1>

        <!-- Module 1 -->
        <div class="module">
            <h2>Module 1. Introduction to Rust</h2>
            <p><b>Theory: </b>Rust is a systems programming language focused on safety, speed, and concurrency. It
                prevents common bugs like null pointer dereferencing and data races.</p>
            <pre><code>fn main() {
    println!("Hello, Rust!");
}
</code></pre>
            <p><b>Practice:</b> Install Rust <code> (rustup) </code> and print "Hello, Rust!".</p>
            <p><b>Quiz:</b> Is Rust compiled or interpreted?</p>
            <button onclick="showAnswer(this, 'Compiled')">Check</button>
            <div class="answer"></div>
        </div>

        <!-- Module 2 -->
        <div class="module">
            <h2>Module 2. Variables and Mutability</h2>
            <p><b>Theory:</b> </p>
            <ul>
                <li>Variables are immutable by default <code> (let) </code>.</li>
                <li>Use <code> mut </code> for mutable variables.</li>
                <li>Use <code> const </code> for constants.</li>
            </ul>
            <pre><code>fn main() {
    let mut x = 10;
    x = 20;
    println!("x = {}", x);
}
</code></pre>
            <p><b>Practice:</b> Create mutable variable x = 10, then change it to 20.</p>
            <p><b>Quiz:</b> Which keyword makes a variable mutable?</p>
            <button onclick="showAnswer(this, 'mut')">Check</button>
            <div class="answer"></div>
        </div>

        <!-- Module 3 -->
        <div class="module">
            <h2>Module 3. Data Types</h2>
            <p><b>Theory:</b> </p>
            <ul>
                <li>Scalar: <code> i32, f64, bool, char </code>.</li>
                <li>Compound: <code> tuple, array</code> .</li>
            </ul>
            <pre><code>fn main() {
    let tup = (10, "Rust", true);
    println!("Number: {}, Text: {}, Bool: {}", tup.0, tup.1, tup.2);
}
</code></pre>
            <p><b>Practice: </b>Make a tuple <code> (10, "Rust", true) </code> and print elements.</p>
            <p><b>Quiz: </b>Which type stores multiple values of different types?</p>
            <button onclick="showAnswer(this, 'Tuple')">Check</button>
            <div class="answer"></div>
        </div>

        <!-- Module 4 -->
        <div class="module">
            <h2>Module 4. Operators</h2>
            <p><b>Theory:</b></p>
            <ul>
                <li>Arithmetic: <code> + - * / % </code></li>
                <li>Comparison: <code> == != > < >= <= </code></li>
                <li>Logical: <code> && || ! </code></li>
            </ul>
            <pre><code>fn main() {
    let x = 5;
    println!("{}", x > 3 && x < 10);
    println!("{}", 10 % 3);
}
</code></pre>
            <p><b>Practice:</b> Check if <code> x = 5 </code> is greater than 3 and less than 10.</p>
            <p><b>Quiz:</b> What does % do?</p>
            <button onclick="showAnswer(this, 'Remainder')">Check</button>
            <div class="answer"></div>
        </div>

        <!-- Module 5 -->
        <div class="module">
            <h2>Module 5. Conditionals</h2>
            <p><b>Theory:</b> Rust uses <code> if, else if, else </code>. Expressions return values.</p>
            <pre><code>fn main() {
    let num = -2;
    if num > 0 {
        println!("Positive");
    } else if num < 0 {
        println!("Negative");
    } else {
        println!("Zero");
    }
}
</code></pre>
            <p><b>Practice:</b> Check if a number is positive, negative, or zero.</p>
            <p><b>Quiz: </b>Can if in Rust return a value?</p>
            <button onclick="showAnswer(this, 'Yes')">Check</button>
            <div class="answer"></div>
        </div>

        <!-- Module 6 -->
        <div class="module">
            <h2>Module 6. Loops</h2>
            <p><b>Theory:</b> </p>
            <ul>
                <li><code>loop</code> → infinite loop.</li>
                <li><code>while</code> → repeats while condition is true.</li>
                <li><code>for</code> → iterates over collections.</li>
            </ul>
            <pre><code>fn main() {
    for i in 1..=5 {
        println!("{}", i);
    }
}
</code></pre>
            <p><b>Practice: </b>Print numbers 1–5 using <code> for </code> .</p>
            <p><b>Quiz: </b>Which keyword makes an infinite loop?</p>
            <button onclick="showAnswer(this, 'loop')">Check</button>
            <div class="answer"></div>
        </div>

        <!-- Module 7 -->
        <div class="module">
            <h2>Module 7. Functions</h2>
            <p><b>Theory:</b> Functions are declared with <code> fn </code>. They can return values.</p>
            <pre><code>fn square(x: i32) -> i32 {
    x * x
}

fn main() {
    println!("{}", square(4));
}
</code></pre>
            <p><b>Practice: </b>Write a function <code> square </code> that returns the square of a number.</p>
            <p><b>Quiz: </b> Which keyword defines a function?</p>
            <button onclick="showAnswer(this, 'fn')">Check</button>
            <div class="answer"></div>
        </div>

        <!-- Module 8 -->
        <div class="module">
            <h2>Module 8. Ownership</h2>
            <p><b>Theory:</b> Ownership ensures memory safety. Rules: </p>
            <ul>
                <li>Each value has one owner.</li>
                <li>When the owner goes out of scope, the value is dropped.</li>
            </ul>
            <pre><code>fn main() {
    let s1 = String::from("Rust");
    let s2 = s1; // ownership moved
    println!("{}", s2);
}
</code></pre>
            <p><b>Practice: </b> Show moving ownership between variables.</p>
            <p><b>Quiz: </b> What happens when the owner goes out of scope?</p>
            <button onclick="showAnswer(this, 'Value is dropped')">Check</button>
            <div class="answer"></div>
        </div>

        <!-- Module 9 -->
        <div class="module">
            <h2>Module 9. Borrowing and References</h2>
            <p><b>Theory:</b> Use <code> & </code> for borrowing, <code> &mut </code> for mutable borrowing.</p>
            <pre><code>fn print_str(s: &String) {
    println!("{}", s);
}

fn main() {
    let s = String::from("Hello");
    print_str(&s);
}
</code></pre>
            <p><b>Practice: </b>Write a function that borrows a string without taking ownership.</p>
            <p><b>Quiz: </b> Which symbol is used for borrowing?</p>
            <button onclick="showAnswer(this, '&')">Check</button>
            <div class="answer"></div>
        </div>

        <!-- Module 10 -->
        <div class="module">
            <h2>Module 10. Structs</h2>
            <p><b>Theory: </b>Structs group related data. Similar to classes without methods. </p>
            <pre><code>struct Person {
    name: String,
    age: u8,
}

fn main() {
    let p = Person { name: String::from("Alice"), age: 22 };
    println!("{} is {}", p.name, p.age);
}
</code></pre>
            <p><b>Practice: </b> Create a struct <code> Person </code> with <code> name </code> and <code> age </code>.
            </p>
            <p><b>Quiz: </b>Which keyword defines a struct?</p>
            <button onclick="showAnswer(this, 'struct')">Check</button>
            <div class="answer"></div>
        </div>

        <!-- Module 11 -->
        <div class="module">
            <h2>Module 11. Enums and Pattern Matching</h2>
            <p><b>Theory:</b> <code> enum </code> represents multiple possible states. Used with <code> match </code>.
            </p>


            <pre><code>enum Direction {
    Up,
    Down,
}

fn main() {
    let dir = Direction::Up;
    match dir {
        Direction::Up => println!("Going up"),
        Direction::Down => println!("Going down"),
    }
}
</code></pre>
            <p><b>Practice: </b>Create an enum Direction with Up, Down, and print it using <code> match </code>.</p>
            <p><b>Quiz: </b>Which keyword defines enums?</p>
            <button onclick="showAnswer(this, 'enum')">Check</button>
            <div class="answer"></div>
        </div>

        <!-- Module 12 -->
        <div class="module">
            <h2>Module 12. Error Handling</h2>
            <p><b>Theory: </b>Rust uses <code> Result<T, E> </code> for recoverable errors and <code> panic! </code> for
                unrecoverable ones.</p>
            <pre><code>use std::fs::File;

fn main() {
    let f = File::open("test.txt");
    match f {
        Ok(_) => println!("File opened!"),
        Err(e) => println!("Error: {}", e),
    }
}
</code></pre>
            <p><b>Practice:</b> Open a file and handle the error with <code> match </code>.</p>
            <p><b>Quiz:</b> Which type is used for recoverable errors?
            </p>
            <button onclick="showAnswer(this, 'Result')">Check</button>
            <div class="answer"></div>
        </div>

        <!-- Module 13 -->
        <div class="module">
            <h2>Module 13. Mini Projects</h2>
            <ul>
                <li>To-Do List (CLI) - Add, view, and remove tasks.</li>
                <li>File Reader - Read a text file and print its contents.</li>
                <li>GSimple Contacts App - Store and search names with phone numbers using a HashMap.</li>
            </ul>
        </div>


    </div>
    <script>
        function showAnswer(btn, text) {
            const div = btn.nextElementSibling;
            div.textContent = "Answer: " + text;
        }

        const burger = document.getElementById('burger');
        const navList = document.querySelector('.nav-list');

        burger.addEventListener('click', () => {
            navList.classList.toggle('show');
        });
        const closeBtn = document.getElementById('close-menu');

        closeBtn.addEventListener('click', () => {
            navList.classList.remove('show');
        });
    </script>
</body>

</html>